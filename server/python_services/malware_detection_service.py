#!/usr/bin/env python3
"""
Malware Detection Service for ScamBane
Implements ClamAV, YARA rules, Malware Bazaar, and Hybrid Analysis integration
"""

import os
import sys
import json
import logging
import tempfile
import subprocess
import hashlib
import requests
import time
from typing import Dict, List, Any, Tuple, Optional

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MalwareDetector:
    """Comprehensive malware detection using multiple services"""
    
    def __init__(self):
        """Initialize API keys and tool paths"""
        # API keys (should be set in environment variables)
        self.malware_bazaar_api_key = os.environ.get('MALTIVERSE_API_KEY')
        self.hybrid_analysis_api_key = os.environ.get('HYBRID_ANALYSIS_API_KEY')
        
        # Tool paths
        self.clamav_path = os.environ.get('CLAMAV_PATH', '/usr/bin')
        self.yara_path = os.environ.get('YARA_PATH', '/usr/bin')
        self.yara_rules_path = os.environ.get('YARA_RULES_PATH', './rules/yara')
        
        # API endpoints
        self.malware_bazaar_url = "https://mb-api.abuse.ch/api/v1/"
        self.hybrid_analysis_url = "https://www.hybrid-analysis.com/api/v2"
    
    def analyze_file(self, file_data: bytes, file_name: str) -> Dict[str, Any]:
        """
        Perform comprehensive malware analysis on a file
        
        Args:
            file_data: Bytes containing the file data
            file_name: Original name of the file
            
        Returns:
            dict: Analysis results from all available methods
        """
        try:
            # Calculate file hashes for lookup
            md5_hash = hashlib.md5(file_data).hexdigest()
            sha1_hash = hashlib.sha1(file_data).hexdigest()
            sha256_hash = hashlib.sha256(file_data).hexdigest()
            
            # Create a temporary file for analysis
            with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                temp_file.write(file_data)
                temp_path = temp_file.name
            
            try:
                # Initialize overall results
                results = {
                    "isMalicious": False,
                    "confidence": 0.0,
                    "malwareType": None,
                    "detectionMethods": [],
                    "detectionsByMethod": {},
                }
                
                # Perform parallel lookups and scans
                # 1. Run ClamAV scan
                try:
                    clam_result = self.scan_with_clamav(temp_path)
                    results["detectionsByMethod"]["clamav"] = clam_result
                    
                    if clam_result["detected"]:
                        results["isMalicious"] = True
                        results["detectionMethods"].append("clamav")
                        
                        # If malware type not yet set, use ClamAV's classification
                        if not results["malwareType"] and clam_result.get("malware_type"):
                            results["malwareType"] = clam_result["malware_type"]
                except Exception as e:
                    logger.error(f"ClamAV scan error: {str(e)}")
                    results["detectionsByMethod"]["clamav"] = {"error": str(e)}
                
                # 2. Run YARA rules
                try:
                    yara_result = self.scan_with_yara(temp_path)
                    results["detectionsByMethod"]["yara"] = yara_result
                    
                    if yara_result["detected"]:
                        results["isMalicious"] = True
                        results["detectionMethods"].append("yara")
                        
                        # If malware type not yet set, use YARA's classification
                        if not results["malwareType"] and yara_result.get("rule_matches"):
                            # Use the first matched rule's category as malware type
                            rule_categories = [rule.get("category") for rule in yara_result["rule_matches"]
                                              if rule.get("category")]
                            if rule_categories:
                                results["malwareType"] = rule_categories[0]
                except Exception as e:
                    logger.error(f"YARA scan error: {str(e)}")
                    results["detectionsByMethod"]["yara"] = {"error": str(e)}
                
                # 3. Check Malware Bazaar
                if self.malware_bazaar_api_key:
                    try:
                        malware_bazaar_result = self.lookup_malware_bazaar(sha256_hash)
                        results["detectionsByMethod"]["malware_bazaar"] = malware_bazaar_result
                        
                        if malware_bazaar_result["detected"]:
                            results["isMalicious"] = True
                            results["detectionMethods"].append("malware_bazaar")
                            
                            # If malware type not yet set, use Malware Bazaar's classification
                            if not results["malwareType"] and malware_bazaar_result.get("malware_type"):
                                results["malwareType"] = malware_bazaar_result["malware_type"]
                    except Exception as e:
                        logger.error(f"Malware Bazaar lookup error: {str(e)}")
                        results["detectionsByMethod"]["malware_bazaar"] = {"error": str(e)}
                
                # 4. Check Hybrid Analysis
                if self.hybrid_analysis_api_key:
                    try:
                        hybrid_analysis_result = self.lookup_hybrid_analysis(sha256_hash)
                        
                        # If not found by hash, submit for analysis
                        if not hybrid_analysis_result["detected"] and file_data and len(file_data) < 50 * 1024 * 1024:  # 50MB
                            submission_result = self.submit_to_hybrid_analysis(temp_path, file_name)
                            if submission_result and submission_result.get("job_id"):
                                hybrid_analysis_result["submission"] = submission_result
                        
                        results["detectionsByMethod"]["hybrid_analysis"] = hybrid_analysis_result
                        
                        if hybrid_analysis_result["detected"]:
                            results["isMalicious"] = True
                            results["detectionMethods"].append("hybrid_analysis")
                            
                            # If malware type not yet set, use Hybrid Analysis's classification
                            if not results["malwareType"] and hybrid_analysis_result.get("malware_type"):
                                results["malwareType"] = hybrid_analysis_result["malware_type"]
                    except Exception as e:
                        logger.error(f"Hybrid Analysis lookup error: {str(e)}")
                        results["detectionsByMethod"]["hybrid_analysis"] = {"error": str(e)}
                
                # Calculate overall confidence (weighted average of all methods)
                self._calculate_overall_confidence(results)
                
                # Add file metadata
                results["metadata"] = {
                    "file_name": file_name,
                    "file_size": len(file_data),
                    "md5": md5_hash,
                    "sha1": sha1_hash,
                    "sha256": sha256_hash
                }
                
                return results
                
            finally:
                # Clean up temporary file
                try:
                    os.unlink(temp_path)
                except Exception as e:
                    logger.error(f"Error removing temp file: {str(e)}")
        
        except Exception as e:
            logger.error(f"Malware detection error: {str(e)}")
            return {
                "isMalicious": False,
                "confidence": 0.0,
                "error": str(e),
                "detectionMethods": []
            }
    
    def _calculate_overall_confidence(self, results: Dict[str, Any]) -> None:
        """Calculate the overall confidence level based on all detection methods"""
        confidence_sum = 0.0
        weight_sum = 0.0
        
        # Define weights for different detection methods
        weights = {
            "clamav": 3.0,
            "yara": 3.0,
            "malware_bazaar": 4.0,
            "hybrid_analysis": 4.0
        }
        
        # Calculate weighted average
        for method, result in results["detectionsByMethod"].items():
            if isinstance(result, dict) and "confidence" in result:
                weight = weights.get(method, 1.0)
                confidence_sum += result["confidence"] * weight
                weight_sum += weight
        
        # Update overall confidence
        if weight_sum > 0:
            results["confidence"] = min(0.99, confidence_sum / weight_sum)
        
        # If detected by multiple sources, increase confidence
        detection_count = len(results["detectionMethods"])
        if detection_count > 1:
            # Boost confidence based on number of detections
            results["confidence"] = min(0.99, results["confidence"] * (1.0 + (detection_count - 1) * 0.1))
    
    def scan_with_clamav(self, file_path: str) -> Dict[str, Any]:
        """
        Scan a file for malware using ClamAV
        
        Args:
            file_path: Path to the file to scan
            
        Returns:
            dict: ClamAV scan results
        """
        try:
            # Run clamscan on the file
            cmd = [f"{self.clamav_path}/clamscan", "-v", "--stdout", file_path]
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = process.communicate()
            
            # Parse output
            output = stdout.decode() + stderr.decode()
            
            # Check if malware was found
            if "FOUND" in output:
                # Extract malware name
                malware_lines = [line for line in output.split('\n') if "FOUND" in line]
                
                if malware_lines:
                    # Parse the first match to get malware name
                    parts = malware_lines[0].split()
                    malware_name = parts[-2] if len(parts) >= 2 else "Unknown"
                    
                    # Categorize by name
                    malware_type = self._categorize_malware_by_name(malware_name)
                    
                    return {
                        "detected": True,
                        "confidence": 0.9,
                        "malware_name": malware_name,
                        "malware_type": malware_type,
                        "detection_count": len(malware_lines),
                        "scan_output": output
                    }
            
            return {
                "detected": False,
                "confidence": 0.0,
                "scan_output": output
            }
        
        except Exception as e:
            logger.error(f"ClamAV scan error: {str(e)}")
            return {
                "detected": False,
                "confidence": 0.0,
                "error": str(e)
            }
    
    def scan_with_yara(self, file_path: str) -> Dict[str, Any]:
        """
        Scan a file for malware using YARA rules
        
        Args:
            file_path: Path to the file to scan
            
        Returns:
            dict: YARA scan results
        """
        try:
            # Ensure YARA rules directory exists
            if not os.path.exists(self.yara_rules_path):
                return {
                    "detected": False,
                    "confidence": 0.0,
                    "error": f"YARA rules path not found: {self.yara_rules_path}"
                }
            
            # Get list of rule files
            rule_files = [
                os.path.join(self.yara_rules_path, f)
                for f in os.listdir(self.yara_rules_path)
                if f.endswith('.yar') or f.endswith('.yara')
            ]
            
            if not rule_files:
                return {
                    "detected": False,
                    "confidence": 0.0,
                    "error": "No YARA rule files found"
                }
            
            # Run YARA scan on the file
            matches = []
            
            for rule_file in rule_files:
                cmd = [f"{self.yara_path}/yara", "-s", rule_file, file_path]
                process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                stdout, stderr = process.communicate()
                
                # Parse output
                output = stdout.decode().strip()
                if output:
                    for line in output.split('\n'):
                        if line.strip():
                            parts = line.split(' ', 1)
                            if len(parts) >= 1:
                                rule_name = parts[0]
                                
                                # Extract category from rule name (e.g., Trojan, Ransomware)
                                rule_category = self._extract_category_from_rule(rule_name)
                                
                                matches.append({
                                    "rule": rule_name,
                                    "category": rule_category,
                                    "file": os.path.basename(rule_file)
                                })
            
            # Determine results
            detected = len(matches) > 0
            confidence = min(0.95, 0.7 + (0.05 * len(matches))) if detected else 0.0
            
            return {
                "detected": detected,
                "confidence": confidence,
                "rule_matches": matches,
                "rule_count": len(matches),
                "categories": list(set(m["category"] for m in matches if m.get("category")))
            }
        
        except Exception as e:
            logger.error(f"YARA scan error: {str(e)}")
            return {
                "detected": False,
                "confidence": 0.0,
                "error": str(e)
            }
    
    def lookup_malware_bazaar(self, sha256_hash: str) -> Dict[str, Any]:
        """
        Look up a file hash in Malware Bazaar
        
        Args:
            sha256_hash: SHA256 hash of the file to check
            
        Returns:
            dict: Malware Bazaar lookup results
        """
        try:
            # Make API request
            headers = {'API-KEY': self.malware_bazaar_api_key}
            data = {'query': 'get_info', 'hash': sha256_hash}
            
            response = requests.post(self.malware_bazaar_url, headers=headers, data=data)
            
            if response.status_code != 200:
                return {
                    "detected": False,
                    "confidence": 0.0,
                    "error": f"API Error: {response.status_code}"
                }
            
            result = response.json()
            
            if result.get('query_status') != 'ok':
                # Sample not found
                return {
                    "detected": False,
                    "confidence": 0.0,
                    "status": result.get('query_status'),
                }
            
            # Sample found - parse data
            if 'data' in result and len(result['data']) > 0:
                sample = result['data'][0]
                
                return {
                    "detected": True,
                    "confidence": 0.95,
                    "malware_name": sample.get('signature', 'Unknown'),
                    "malware_type": sample.get('tags', ['malware'])[0] if sample.get('tags') else 'malware',
                    "first_seen": sample.get('first_seen'),
                    "file_name": sample.get('file_name'),
                    "reporter": sample.get('reporter'),
                    "tags": sample.get('tags', [])
                }
            
            return {
                "detected": False,
                "confidence": 0.0
            }
            
        except Exception as e:
            logger.error(f"Malware Bazaar lookup error: {str(e)}")
            return {
                "detected": False,
                "confidence": 0.0,
                "error": str(e)
            }
    
    def lookup_hybrid_analysis(self, sha256_hash: str) -> Dict[str, Any]:
        """
        Look up a file hash in Hybrid Analysis
        
        Args:
            sha256_hash: SHA256 hash of the file to check
            
        Returns:
            dict: Hybrid Analysis lookup results
        """
        try:
            # Make API request
            headers = {
                'api-key': self.hybrid_analysis_api_key,
                'user-agent': 'ScamBane Security Scanner',
                'accept': 'application/json'
            }
            
            url = f"{self.hybrid_analysis_url}/search/hash"
            params = {'hash': sha256_hash}
            
            response = requests.post(url, headers=headers, data=params)
            
            if response.status_code != 200:
                return {
                    "detected": False,
                    "confidence": 0.0,
                    "error": f"API Error: {response.status_code}"
                }
            
            result = response.json()
            
            # Check if result is empty
            if not result or len(result) == 0:
                return {
                    "detected": False,
                    "confidence": 0.0,
                    "message": "Sample not found"
                }
            
            # Process result
            sample = result[0]  # Get first match
            
            # Check verdict (see if it's malicious)
            verdict = sample.get('verdict')
            threat_score = sample.get('threat_score', 0)
            is_malicious = verdict in ['malicious', 'suspicious'] or threat_score >= 50
            
            if is_malicious:
                return {
                    "detected": True,
                    "confidence": min(0.99, threat_score / 100.0),
                    "malware_name": sample.get('vx_family', 'Unknown'),
                    "malware_type": sample.get('type_short', ['malware'])[0] if sample.get('type_short') else 'malware',
                    "analysis_id": sample.get('analysis_id'),
                    "verdict": verdict,
                    "threat_score": threat_score,
                    "av_detect": sample.get('av_detect'),
                    "environment": sample.get('environment_description'),
                    "analysis_url": sample.get('analysis_url')
                }
            
            return {
                "detected": False,
                "confidence": 0.0,
                "verdict": verdict,
                "threat_score": threat_score
            }
            
        except Exception as e:
            logger.error(f"Hybrid Analysis lookup error: {str(e)}")
            return {
                "detected": False,
                "confidence": 0.0,
                "error": str(e)
            }
    
    def submit_to_hybrid_analysis(self, file_path: str, file_name: str) -> Dict[str, Any]:
        """
        Submit a file to Hybrid Analysis for scanning
        
        Args:
            file_path: Path to the file to submit
            file_name: Original name of the file
            
        Returns:
            dict: Submission results
        """
        try:
            # Make API request
            headers = {
                'api-key': self.hybrid_analysis_api_key,
                'user-agent': 'ScamBane Security Scanner'
            }
            
            url = f"{self.hybrid_analysis_url}/submit/file"
            
            with open(file_path, 'rb') as file:
                files = {'file': (file_name, file)}
                data = {'environment_id': 120}  # Windows 10 x64 environment
                
                response = requests.post(url, headers=headers, files=files, data=data)
            
            if response.status_code != 200:
                return {
                    "success": False,
                    "error": f"API Error: {response.status_code}"
                }
            
            result = response.json()
            
            # Return job ID if successful
            if result.get('job_id'):
                return {
                    "success": True,
                    "job_id": result.get('job_id'),
                    "environment_id": result.get('environment_id'),
                    "sha256": result.get('sha256')
                }
            
            return {
                "success": False,
                "message": result.get('message', 'Unknown error')
            }
            
        except Exception as e:
            logger.error(f"Hybrid Analysis submission error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def _categorize_malware_by_name(self, name: str) -> str:
        """Categorize malware by name pattern"""
        name = name.lower()
        
        # Map of patterns to malware types
        categories = [
            ("trojan", "trojan"),
            ("ransom", "ransomware"),
            ("crypto", "cryptominer"),
            ("miner", "cryptominer"),
            ("backdoor", "backdoor"),
            ("rootkit", "rootkit"),
            ("spyware", "spyware"),
            ("adware", "adware"),
            ("worm", "worm"),
            ("exploit", "exploit"),
            ("keylogger", "keylogger"),
            ("banker", "banker"),
            ("stealer", "stealer"),
            ("dropper", "dropper"),
            ("bot", "botnet"),
            ("rat", "remote_access_trojan"),
            ("virus", "virus"),
            ("packed", "packed_malware"),
            ("injector", "code_injection"),
            ("downloader", "downloader")
        ]
        
        for pattern, category in categories:
            if pattern in name:
                return category
                
        return "malware"
    
    def _extract_category_from_rule(self, rule_name: str) -> Optional[str]:
        """Extract malware category from YARA rule name"""
        rule_name = rule_name.lower()
        
        # Common patterns in YARA rule naming
        categories = [
            ("trojan", "trojan"),
            ("ransomware", "ransomware"),
            ("ransom", "ransomware"),
            ("crypter", "crypter"),
            ("miner", "cryptominer"),
            ("backdoor", "backdoor"),
            ("rootkit", "rootkit"),
            ("spyware", "spyware"),
            ("keylogger", "keylogger"),
            ("stealer", "stealer"),
            ("banker", "banker"),
            ("worm", "worm"),
            ("exploit", "exploit"),
            ("dropper", "dropper"),
            ("rat", "remote_access_trojan"),
            ("apt", "apt"),
            ("bot", "botnet"),
            ("ddos", "ddos"),
            ("downloader", "downloader"),
            ("injector", "code_injection"),
            ("packer", "packed_malware"),
            ("webshell", "webshell"),
            ("adware", "adware")
        ]
        
        for pattern, category in categories:
            if pattern in rule_name:
                return category
                
        return None

# Create singleton instance
malware_detector = MalwareDetector()

# API function to be called from Node.js
def analyze_file_for_malware(file_data, file_name):
    """API function for Node.js integration"""
    return malware_detector.analyze_file(file_data, file_name)

# Command line testing
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python malware_detection_service.py <file_path>")
        sys.exit(1)
    
    with open(sys.argv[1], 'rb') as f:
        file_data = f.read()
    
    result = malware_detector.analyze_file(file_data, os.path.basename(sys.argv[1]))
    print(json.dumps(result, indent=2))